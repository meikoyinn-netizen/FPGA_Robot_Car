`timescale 1ns / 1ps

module tb_top_test();

    reg clk;
    reg rst_n;

    // 连接线
    wire [31:0] pc_to_imem;
    wire [31:0] inst_to_decoder;
    
    // 译码器输出的信号（我们要观察的对象）
    wire [6:0]  opcode;
    wire [4:0]  rd;
    wire [31:0] imm;

    // 1. 时钟和复位
    initial begin
        clk = 0;
        forever #10 clk = ~clk;
    end

    initial begin
        rst_n = 0;
        #55 rst_n = 1; // 复位后开始运行
        #200 $stop;
    end

    // 2. 实例化 PC (已完成模块)
    my_pc_reg u_pc (
        .clk(clk),
        .rst_n(rst_n),
        .stall(1'b0),        // 暂时不暂停
        .jump_flag(1'b0),    // 暂时不跳转
        .jump_addr(32'b0),
        .pc_o(pc_to_imem)
    );

    // 3. 实例化 IMEM (已完成模块)
    my_imem u_imem (
        .addr(pc_to_imem),
        .inst(inst_to_decoder)
    );

    // 4. 实例化 Decoder (刚刚写的模块)
    my_decoder u_decoder (
        .inst_i(inst_to_decoder),
        .opcode_o(opcode),
        .rd_o(rd),
        .imm_o(imm),
        // 其他信号暂不连，先看这几个
        .func3_o(), .func7_o(), .rs1_o(), .rs2_o()
    );

endmodule